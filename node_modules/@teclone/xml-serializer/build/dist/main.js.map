{"version":3,"file":"main.js","sources":["../../node_modules/@babel/runtime/helpers/classCallCheck.js","../../node_modules/@babel/runtime/helpers/createClass.js","../../src/modules/Util.js","../../src/modules/Serializer.js","../../src/main.js"],"sourcesContent":["function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nmodule.exports = _classCallCheck;","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nmodule.exports = _createClass;","/**\n * Utility module\n * this module defines a bunch of utility functions that will be relevant to most other modules\n */\nexport default {\n  /**\n   * tests if a variable is a DOCUMENT_NODE\n   *@param {*} node - node to test\n   *@returns {boolean}\n   */\n  isDocumentNode(node) {\n    return node && node.nodeType === 9;\n  },\n\n  /**\n   * tests if a variable is an ELEMENT_NODE\n   *@param {*} node - node to test\n   *@returns {boolean}\n   */\n  isElementNode(node) {\n    return node && node.nodeType === 1;\n  },\n\n  /**\n   * tests if a variable is an ATTRIBUTE_NODE\n   *@param {*} node - node to test\n   *@returns {boolean}\n   */\n  isAttributeNode(node) {\n    return (\n      node &&\n      (node.nodeType === 2 || Object.prototype.toString.call(node) === '[object Attr]')\n    );\n  },\n\n  /**\n   * tests if a variable is a TEXT_NODE\n   *@param {*} node - node to test\n   *@returns {boolean}\n   */\n  isTextNode(node) {\n    return node && node.nodeType === 3;\n  },\n\n  /**\n   * tests if a variable is a PROCESSING_INSTRUCTION_NODE\n   *@param {*} node - node to test\n   *@returns {boolean}\n   */\n  isProcessingInstructionNode(node) {\n    return node && node.nodeType === 7;\n  },\n\n  /**\n   * tests if a variable is a COMMENT_NODE\n   *@param {*} node - node to test\n   *@returns {boolean}\n   */\n  isCommentNode(node) {\n    return node && node.nodeType === 8;\n  },\n\n  /**\n   * tests if a variable is a DOCUMENT_TYPE_NODE\n   *@param {*} node - node to test\n   *@returns {boolean}\n   */\n  isDocTypeNode(node) {\n    return node && node.nodeType === 10;\n  },\n\n  /**\n   * tests if a variable is a DOM_FRAGMENT_NODE\n   *@param {*} node - node to test\n   *@returns {boolean}\n   */\n  isDOMFragmentNode(node) {\n    return node && node.nodeType === 11;\n  },\n};\n","import Util from './Util.js';\n\nconst XML_NS = 'http://www.w3.org/XML/1998/namespace',\n  XMLNS_NS = 'http://www.w3.org/2000/xmlns/',\n  HTML_NS = 'http://www.w3.org/1999/xhtml';\n\nexport default class Serializer {\n  /**\n   * creates an xml serializer\n   *@param {boolean} [preserveWhiteSpace=false] - boolean value indicating if it should preserve\n   * white spaces. defaults to false\n   */\n  constructor(preserveWhiteSpace) {\n    this.prefixIndex = 1;\n    this.dupPrefixDef = [];\n    this.preserveWhiteSpace = preserveWhiteSpace === false ? false : true;\n  }\n\n  /**\n   * tests if the given text value is a valid xml name production\n   *@param {string} value - the text value\n   *@returns {boolean}\n   */\n  validateXMLNameProduction(value) {\n    let nameStart =\n        '[a-z]|[:]|[_]|[\\\\u00C0-\\\\u00D6]|[\\\\u00D8-\\\\u00F6]|[\\\\u00F8-\\\\u02FF]|' +\n        '[\\\\u0370-\\\\u037D]|[\\\\u037F-\\\\u1FFF]|[\\\\u200C-\\\\u200D]|[\\\\u2070-\\\\u218F]|' +\n        '[\\\\u2C00-\\\\u2FEF]|[\\\\u3001-\\\\uD7FF]|[\\\\uF900-\\\\uFDCF]|[\\\\uFDF0-\\\\uFFFD]|' +\n        '[\\\\uD800-\\\\uDBFF]|[\\\\uDC00-\\\\uDFFF]',\n      nameChar =\n        nameStart + '|[\\\\-]|[.]|[0-9]|\\\\u00B7|[\\\\u0300-\\\\u036F]|[\\\\u203F-\\\\u2040]';\n\n    let regex = new RegExp(`^(${nameStart})(${nameChar})*`, 'i');\n    return typeof value === 'string' && regex.test(value);\n  }\n\n  /**\n   * tests if the given text value is a valid xml tag name\n   *@param {string} value - the text value\n   *@returns {boolean}\n   */\n  validateXMLTagName(value) {\n    return this.validateXMLNameProduction(value) && !/^xml/i.test(value);\n  }\n\n  /**\n   * tests if the given text value is a valid xml attribute name\n   *@param {string} value - the text value\n   *@param {string} attrNS - attribute namespace value\n   *@returns {boolean}\n   */\n  validateXMLAttrName(value, attrNS) {\n    return (\n      this.validateXMLNameProduction(value) &&\n      (value.toLowerCase() !== 'xmlns' || attrNS !== null)\n    );\n  }\n\n  /**\n   * validates xml char\n   *@param {string} value - char to validate\n   *@returns {boolean}\n   */\n  validateChar(value) {\n    let char =\n      '[\\\\u0009]|[\\\\u000A]|[\\\\u000D]|[\\\\u0020-\\uD7FF]|[\\\\uE000-\\\\uFFFD]|' +\n      '[\\\\uD800-\\\\uDBFF]|[\\\\uDC00-\\\\uDFFF]';\n\n    let regex = new RegExp(`^(${char})*$`);\n    return typeof value === 'string' && regex.test(value);\n  }\n\n  /**\n   * validates xml comment\n   *@param {string} comment - the xml comment\n   *@returns {boolean}\n   */\n  validateComment(comment) {\n    return (\n      this.validateChar(comment) &&\n      comment.indexOf('--') < 0 &&\n      comment.charAt(comment.length - 1) !== '-'\n    );\n  }\n\n  /**\n   * tests if the public id given is valid\n   *@param {string} pubId - the public id\n   *@returns {boolean}\n   */\n  validatePublicId(pubId) {\n    let pubIdChar = \"[\\\\u0020]|[\\\\u000D]|[\\\\u000A]|[a-zA-Z0-9]|[\\\\-\\\\'()+,./:=?;!*#@$_%]\";\n\n    let regex = new RegExp(`^(${pubIdChar})*$`);\n    return typeof pubId === 'string' && regex.test(pubId);\n  }\n\n  /**\n   * tests if the systemId given is valid\n   *@param {string} systemId - the systemId\n   *@returns {boolean}\n   */\n  validateSystemId(systemId) {\n    return this.validateChar(systemId);\n  }\n\n  /**\n   * validates xml processing instruction target value\n   *@param {string} target - the target text\n   *@returns {boolean}\n   */\n  validatePITarget(target) {\n    return (\n      this.validateChar(target) &&\n      target.indexOf(':') < 0 &&\n      target.toLowerCase() !== 'xml'\n    );\n  }\n\n  /**\n   * validates xml processing instruction data value\n   *@param {string} data - the data value\n   *@returns {boolean}\n   */\n  validatePIData(data) {\n    return this.validateChar(data) && data.indexOf('?>') < 0;\n  }\n\n  /**\n   * checks if the given tuple consisting of namespaceURI and localName pair exists in the records\n   *@param {Array} records - tuple records\n   *@param {Array} tuple - the tuple to check\n   *@returns {boolean}\n   */\n  tupleExists(records, tuple) {\n    let exists = false,\n      len = tuple.length;\n    for (let record of records) {\n      if (len === record.length) {\n        exists = true;\n        let i = -1;\n        while (++i < len) {\n          if (record[i] !== tuple[i]) {\n            exists = false;\n            break;\n          }\n        }\n      }\n      if (exists) break;\n    }\n    return exists;\n  }\n\n  /**\n   * generate a element prefix\n   *@param {Map} map - namespace prefix map,\n   *@param {string} ns - the new namespace\n   *@returns {string}\n   *@see https://www.w3.org/TR/DOM-Parsing/#dfn-concept-generate-prefix\n   */\n  generatePrefix(map, ns) {\n    let generatedPrefix = 'ns' + this.prefixIndex++;\n    map[ns] = generatedPrefix;\n\n    return generatedPrefix;\n  }\n\n  /**\n   * records the namespace information for an element\n   *@param {Element} elem - the element node\n   *@param {Map} prefixMap - element prefix to namespace map\n   *@param {Array} elmPrefixList - element current prefix list\n   *@returns {string}\n   *@see https://www.w3.org/TR/DOM-Parsing/#dfn-concept-record-namespace-info\n   */\n  recordElementNSInfo(elem, prefixMap, elmPrefixList) {\n    //STEP 1\n    let defNSAttrValue = null,\n      attributes = elem.attributes,\n      i = -1,\n      len = attributes.length;\n\n    //STEP 2\n    while (++i < len) {\n      //STEP 2. 1, 2\n      let attr = attributes[i],\n        attrNS = attr.namespaceURI,\n        attrPrefix = attr.prefix;\n      //STEP 2.3\n      if (attrNS === XMLNS_NS) {\n        //STEP 2.3.1\n        if (attrPrefix === null) {\n          defNSAttrValue = attr.value;\n          continue;\n        }\n\n        // STEP 2.3.2\n        //STEP 2.3.2.1 & 2.3.2.2\n        let prefixDef = attr.localName,\n          nsDef = attr.value;\n\n        //STEP 2.3.2.3\n        if (typeof prefixMap[nsDef] !== 'undefined' && prefixMap[nsDef] === prefixDef)\n          this.dupPrefixDef.push(prefixDef);\n        //STEP 2.3.2.4 & 2.3.2.5 combined\n        else prefixMap[nsDef] = prefixDef;\n\n        //STEP 2.3.3.6\n        elmPrefixList.push(prefixDef);\n      }\n    }\n    return defNSAttrValue;\n  }\n\n  /**\n   * serializes an attribute value given an attribute value and require well-formed flag\n   *@param {string} value - the attribute value\n   *@param {boolean} requireWellFormed - boolean value indicating if well formedness is a\n   * requirement\n   *@returns {string}\n   *@see https://www.w3.org/TR/DOM-Parsing/#dfn-concept-serialize-attr-value\n   */\n  serializeAttrValue(value, requireWellFormed) {\n    if (requireWellFormed && !this.validateChar(value))\n      throw new Error(value + ' is not a valid attribute value');\n\n    if (value === null) return '';\n\n    return value\n      .replace('\"', '&quot;')\n      .replace('&', '&amp;')\n      .replace('<', '&lt;')\n      .replace('>', '&gt;');\n  }\n\n  /**\n   * produces the XML serialization of the attributes of an element\n   *@param {Element} node - the element node\n   *@param {Map} map - namespace prefix map,\n   *@param {boolean} ignoreNSDefAttr - a boolean ignore namespace definition attribute flag,\n   *@param {string} dupPrefixDef - a duplicate prefix definition value\n   *@param {boolean} requireWellFormed - a boolean require well-formed xml flag\n   *@returns {string}\n   *@see https://www.w3.org/TR/DOM-Parsing/#dfn-concept-serialize-xml-attributes\n   */\n  serializeAttributes(node, map, ignoreNSDefAttr, requireWellFormed) {\n    //STEP 1, 2\n    let result = '',\n      localNameSet = [];\n\n    let attributes = node.attributes,\n      i = -1,\n      len = attributes.length;\n\n    //STEP 3\n    while (++i < len) {\n      let attr = attributes[i],\n        nsURI = attr.namespaceURI,\n        localName = attr.localName,\n        prefix = attr.prefix;\n\n      let tuple = [nsURI, localName];\n      //STEP 3.1\n      /* istanbul ignore if */\n      if (requireWellFormed && this.tupleExists(localNameSet, tuple))\n        throw new Error(\n          'element cannot have two attributes with the same namespaceURI and localName',\n        );\n\n      //STEP 3.2\n      localNameSet.push(tuple);\n\n      //STEP 3. 3, 4\n      let attrNS = nsURI,\n        candidatePrefix = null;\n      //STEP 3.5\n      /* istanbul ignore else */\n      if (attrNS !== null) {\n        //STEP 3.5.1\n        if (\n          attrNS === XMLNS_NS &&\n          ((prefix === null && ignoreNSDefAttr) ||\n            (prefix !== null && this.dupPrefixDef.includes(localName)))\n        ) {\n          continue;\n        } else if (prefix === null) {\n          candidatePrefix = null;\n        }\n\n        //STEP 3.5.2\n        else if (typeof map[attrNS] !== 'undefined') {\n          candidatePrefix = map[attrNS];\n        }\n\n        //STEP 3.5.3\n        else {\n          candidatePrefix = this.generatePrefix(map, attrNS);\n          result += ` xmlns:${candidatePrefix}=\"${this.serializeAttrValue(attrNS)}\"`;\n        }\n      }\n\n      //STEP 3.6\n      result += ' ';\n\n      //STEP 3.7\n      if (candidatePrefix !== null) result += candidatePrefix + ':';\n\n      //STEP 3.8\n      /* istanbul ignore if */\n      if (requireWellFormed && !this.validateXMLAttrName(localName, attrNS))\n        throw new Error(localName + ' is not a valid xml attribute name');\n\n      //STEP 3.9\n      result += `${localName}=\"${this.serializeAttrValue(attr.value)}\"`;\n    }\n\n    //STEP 4\n    return result;\n  }\n\n  /**\n   * serializes processing instruction node\n   *@param {ProcessingInstruction} node - the processing instruction node\n   *@param {boolean} requireWellFormed - boolean value indicating if well formedness is a\n   * requirement\n   *@returns {string}\n   */\n  serializeProcessingInstruction(node, requireWellFormed) {\n    //STEP 1\n    if (requireWellFormed && !this.validatePITarget(node.target))\n      throw new Error(\n        node.target + ' is not a valid processing instruction target value',\n      );\n\n    //STEP 2\n    if (requireWellFormed && !this.validatePIData(node.data))\n      throw new Error(\n        node.data + ' contains invalid processing instruction character values',\n      );\n\n    let target = this.preserveWhiteSpace ? node.target : node.target.trim(),\n      data = this.preserveWhiteSpace ? node.data : node.data.trim();\n    //STEP 4\n    let markup = `<?${target} ${data}?>`;\n\n    //STEP 4\n    return markup;\n  }\n\n  /**\n   * generate document type serialization\n   *@param {DocumentType} docType - the document type node\n   *@param {boolean} requireWellFormed - boolean value indicating if well formedness is a\n   * requirement\n   *@returns {string}\n   *@see https://www.w3.org/TR/DOM-Parsing/#dfn-concept-serialize-doctype\n   */\n  serializeDocumentType(docType, requireWellFormed) {\n    //STEP 1\n    if (requireWellFormed && !this.validatePublicId(docType.publicId))\n      throw new Error(\n        docType.publicId + ' contains invalid xml document pubId character value',\n      );\n\n    //STEP 2\n    if (requireWellFormed && !this.validateSystemId(docType.systemId))\n      throw new Error(\n        docType.systemId + ' contains invalid xml document systemId character value',\n      );\n\n    //STEP 3, 4, 5\n    let markup = '<!DOCTYPE ',\n      publicId = this.preserveWhiteSpace ? docType.publicId : docType.publicId.trim(),\n      systemId = this.preserveWhiteSpace ? docType.systemId : docType.systemId.trim();\n\n    if (publicId === '' && systemId === '' && /^html$/i.test(docType.name))\n      markup += docType.name.toLowerCase();\n    else markup += docType.name;\n\n    //STEP 7\n    if (publicId !== '') markup += ` PUBLIC \"${publicId}\"`;\n\n    //STEP 8\n    if (systemId !== '' && publicId === '') markup += ` SYSTEM`;\n\n    //STEP 9\n    if (systemId !== '') markup += ` \"${systemId}\"`;\n\n    //STEP 10\n    markup += '>';\n\n    return markup;\n  }\n\n  /**\n   * runs the XML serialization algorithm on a document fragment node\n   *@param {DocumentFragment} node - the document fragment node.\n   *@param {string} namespace - context namespace\n   *@param {Map} prefixMap - a namespace prefix map\n   *@param {boolean} requireWellFormed - a require well-formed flag\n   *@returns {string}\n   *@see https://www.w3.org/TR/DOM-Parsing/#dfn-concept-xml-serialization-algorithm\n   */\n  serializeDocumentFragment(node, namespace, prefixMap, requireWellFormed) {\n    let markup = '',\n      childNodes = node.childNodes,\n      len = childNodes.length,\n      i = -1;\n\n    while (++i < len) {\n      markup += this.runSerialization(\n        childNodes[i],\n        namespace,\n        prefixMap,\n        requireWellFormed,\n      );\n    }\n    return markup;\n  }\n\n  /**\n   * produces the XML serialization of a comment node\n   *@param {Text} node - the text node\n   *@param {boolean} requireWellFormed - a boolean require well-formed xml flag\n   *@returns {string}\n   */\n  serializeText(node, requireWellFormed) {\n    if (requireWellFormed && !this.validateChar(node.data))\n      throw new Error(node.data + ' is not a valid xml text data');\n\n    let data = this.preserveWhiteSpace ? node.data : node.data.trim();\n    return data\n      .replace(/\\&/g, '&amp;')\n      .replace(/</g, '&lt;')\n      .replace(/>/g, '&gt;');\n  }\n\n  /**\n   * produces the XML serialization of a comment node\n   *@param {Comment} node - the comment node\n   *@param {boolean} requireWellFormed - a boolean require well-formed xml flag\n   *@returns {string}\n   */\n  serializeComment(node, requireWellFormed) {\n    if (requireWellFormed && !this.validateComment(node.data))\n      throw new Error(node.data + ' is not a valid xml comment data');\n\n    return '<!--' + node.data + '-->';\n  }\n\n  /**\n   * runs the XML serialization algorithm on a document node\n   *@param {Element} node - the element node.\n   *@param {string} namespace - context namespace\n   *@param {Map} prefixMap - a namespace prefix map\n   *@param {boolean} requireWellFormed - a require well-formed flag\n   *@returns {string}\n   *@see https://www.w3.org/TR/DOM-Parsing/#dfn-concept-xml-serialization-algorithm\n   */\n  serializeDocument(node, namespace, prefixMap, requireWellFormed) {\n    if (requireWellFormed && node.documentElement === null)\n      throw new Error('document has no document element root');\n\n    let serializeDocument = `<?xml version=\"1.0\" encoding=\"${node.characterSet}\"?>`;\n\n    let childNodes = node.childNodes,\n      len = childNodes.length,\n      i = -1;\n\n    while (++i < len) {\n      serializeDocument += this.runSerialization(\n        childNodes[i],\n        namespace,\n        prefixMap,\n        requireWellFormed,\n      );\n    }\n    return serializeDocument;\n  }\n\n  /**\n   * runs the XML serialization algorithm on an element node\n   *@param {Element} node - the element node.\n   *@param {string} namespace - context namespace\n   *@param {Map} prefixMap - a namespace prefix map\n   *@param {boolean} requireWellFormed - a require well-formed flag\n   *@returns {string}\n   *@see https://www.w3.org/TR/DOM-Parsing/#dfn-concept-xml-serialization-algorithm\n   */\n  serializeElement(node, namespace, prefixMap, requireWellFormed) {\n    let localName = node.localName; //get element local name\n\n    // STEP 1: if require well formed is true, and local name is not a valid xml tag name, throw error\n    /* istanbul ignore if */\n    if (requireWellFormed && !this.validateXMLTagName(localName))\n      throw new Error(localName + ' is not a valid xml element local name');\n\n    //STEP 2, 3, 4, 5, 6, 7\n    //declare markup, element qualified tag name, skip end tag boolean value, ignore\n    //namespace definition attribute, prefix map copy, element prefix list and\n    //duplicate prefix definition variables\n    let markup = '<',\n      qualifiedName = '',\n      skipEndTag = false,\n      ignoreNSDefAttr = false,\n      map = Object.assign(Object.create(null), prefixMap),\n      elmPrefixList = [];\n\n    //STEP 8\n    this.dupPrefixDef = [];\n\n    //STEP 9:\n    //get local definition namespace, update map copy and add any new element prefixes\n    let localDefNS = this.recordElementNSInfo(\n        node,\n        map,\n        elmPrefixList,\n        this.dupPrefixDef,\n      ),\n      //STEP 10, 11\n      //delcare inherited namespace as parent namespace, and ns as node namespace uri\n      inheritedNS = namespace,\n      ns = node.namespaceURI;\n\n    //STEP 12\n    if (inheritedNS === ns) {\n      //STEP 12.1\n      /* istanbul ignore if */\n      if (localDefNS !== null) ignoreNSDefAttr = true;\n\n      //STEP 12.2\n      /* istanbul ignore if */\n      if (ns === XML_NS) qualifiedName = 'xml:' + localName;\n      //STEP 12.3\n      else qualifiedName = localName;\n\n      //STEP 12.4\n      markup += qualifiedName;\n    }\n\n    //STEP 13\n    else {\n      //STEP 13. 1, 2\n      let prefix = node.prefix,\n        candidatePrefix = typeof map[ns] !== 'undefined' ? map[ns] : null;\n\n      //STEP 13.3\n      /* istanbul ignore else */\n      if (candidatePrefix !== null) {\n        //STEP 13.3.1\n        qualifiedName = candidatePrefix + ':' + localName;\n\n        //STEP 13.3.2\n        /* istanbul ignore if */\n        if (localDefNS !== null) inheritedNS = ns;\n\n        //STEP 13.3.3\n        markup += qualifiedName;\n      }\n\n      //STEP 13.4\n      else if (prefix !== null && localDefNS === null) {\n        //STEP 13.4.1\n        if (elmPrefixList.includes(prefix)) {\n          // it will use the prefixIndex instance variable. as js can't pass values by reference\n          prefix = this.generatePrefix(map, ns);\n        }\n        //STEP 13.4.2\n        else {\n          map[ns] = prefix;\n        }\n\n        //STEP 13.4.3\n        qualifiedName = prefix + ':' + localName;\n        //STEP 13.4.4\n        markup += qualifiedName;\n\n        //STEP 13.4.5. 1, 2, 3, 4, 5, 6\n        markup += ` xmlns:${prefix}=\"${this.serializeAttrValue(ns, requireWellFormed)}\"`;\n      }\n\n      //STEP 13.5\n      else if (localDefNS === null || localDefNS !== ns) {\n        //STEP 13.5. 1, 2, 3\n        ignoreNSDefAttr = true;\n        qualifiedName = localName;\n        inheritedNS = ns;\n\n        //STEP 13.5.4\n        markup += qualifiedName;\n\n        //STEP 13.5.5. 1, 2, 3, 4, 5, 6\n        markup += ` xmlns=\"${this.serializeAttrValue(ns, requireWellFormed)}\"`;\n      }\n\n      //STEP 13.6\n      else {\n        qualifiedName = localName;\n        inheritedNS = ns;\n        markup += qualifiedName;\n      }\n    }\n\n    //STEP 14\n    markup += this.serializeAttributes(node, map, ignoreNSDefAttr, requireWellFormed);\n\n    //STEP 15\n    if (\n      ns === HTML_NS &&\n      !node.hasChildNodes() &&\n      /^(area|base|basefont|bgsound|br|col|embed|frame|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)$/i.test(\n        localName,\n      )\n    ) {\n      markup += ' /';\n      skipEndTag = true;\n    }\n\n    //STEP 16\n    if (ns !== HTML_NS && !node.hasChildNodes()) {\n      markup += '/';\n      skipEndTag = true;\n    }\n\n    //STEP 17\n    markup += '>';\n\n    //STEP 18\n    if (skipEndTag) return markup;\n\n    //STEP 19\n    if (ns === HTML_NS && localName.toLowerCase() === 'template') {\n      markup += this.runSerialization(node.content, inheritedNS, map, requireWellFormed);\n    }\n\n    //STEP 20\n    else {\n      let len = node.childNodes.length,\n        i = -1;\n      while (++i < len) {\n        markup += this.runSerialization(\n          node.childNodes[i],\n          inheritedNS,\n          map,\n          requireWellFormed,\n        );\n      }\n    }\n\n    //STEP 21\n    markup += '</' + qualifiedName + '>';\n\n    return markup;\n  }\n\n  /**\n   * runs the XML serialization algorithm on depending on the node type\n   *@param {Element} node - the element node.\n   *@param {string} contextNamespace - context namespace\n   *@param {Map} namespacePrefixes - a namespace prefix map\n   *@param {boolean} requireWellFormed - a require well-formed flag\n   *@returns {string}\n   *@see https://www.w3.org/TR/DOM-Parsing/#dfn-concept-serialize-xml\n   */\n  runSerialization(node, contextNamespace, namespacePrefixes, requireWellFormed) {\n    if (Util.isElementNode(node))\n      return this.serializeElement(\n        node,\n        contextNamespace,\n        namespacePrefixes,\n        requireWellFormed,\n      );\n\n    if (Util.isDocumentNode(node))\n      return this.serializeDocument(\n        node,\n        contextNamespace,\n        namespacePrefixes,\n        requireWellFormed,\n      );\n\n    if (Util.isCommentNode(node)) return this.serializeComment(node, requireWellFormed);\n\n    if (Util.isTextNode(node)) return this.serializeText(node, requireWellFormed);\n\n    if (Util.isDOMFragmentNode(node))\n      return this.serializeDocumentFragment(\n        node,\n        contextNamespace,\n        namespacePrefixes,\n        requireWellFormed,\n      );\n\n    if (Util.isDocTypeNode(node))\n      return this.serializeDocumentType(node, requireWellFormed);\n\n    return this.serializeProcessingInstruction(node, requireWellFormed);\n  }\n\n  /**\n   * produces an XML serialization of root passing a value of false for the\n   * require well-formed parameter, and return the result.\n   *@see https://www.w3.org/TR/DOM-Parsing/#the-xmlserializer-interface\n   *@param {Node} root - the root node\n   *@param {boolean} [requireWellFormed=false] - boolean value indicating if it should require xml\n   * well formedness\n   *@returns {string}\n   */\n  serializeToString(root, requireWellFormed) {\n    //STEP 1, 2\n    let contextNamespace = null,\n      namespacePrefixes = Object.create(null); //use object.create to help support older browsers\n\n    //STEP 3\n    //initialize the namspace prefix with xml namspace\n    namespacePrefixes[XMLNS_NS] = 'xmlns';\n\n    //STEP 4\n    this.prefixIndex = 1;\n\n    requireWellFormed = requireWellFormed ? true : false;\n\n    return this.runSerialization(\n      root,\n      contextNamespace,\n      namespacePrefixes,\n      requireWellFormed,\n    );\n  }\n}\n","import Serializer from './modules/Serializer.js';\n\nclass XMLSerializer {\n  /**\n   *@param {boolean} [preserveWhiteSpace=true] - boolean value indicating if white spaces\n   * should be preserved as it is in the source\n   */\n  constructor(preserveWhiteSpace) {\n    this.serializer = new Serializer(preserveWhiteSpace);\n  }\n\n  /**\n   * return XMLSerializer as modules name\n   */\n  get [Symbol.toStringTag]() {\n    return 'XMLSerializer';\n  }\n\n  /**\n   * produces an XML serialization of root passing a value of false for the\n   * require well-formed parameter, and return the result.\n   *@param {Node} root - the root node\n   *@param {boolean} [requireWellFormed=false] - boolean value indicating if it should require xml\n   * well formedness\n   *@returns {string}\n   */\n  serializeToString(root, requireWellFormed) {\n    return this.serializer.serializeToString(root, requireWellFormed);\n  }\n}\n\n/**\n * installs the serialize to the given target object\n */\nXMLSerializer.installTo = target => {\n  target.XMLSerializer = XMLSerializer;\n};\n\nexport default XMLSerializer;\n"],"names":["isDocumentNode","node","nodeType","isElementNode","isAttributeNode","Object","prototype","toString","call","isTextNode","isProcessingInstructionNode","isCommentNode","isDocTypeNode","isDOMFragmentNode","XML_NS","XMLNS_NS","HTML_NS","Serializer","preserveWhiteSpace","prefixIndex","dupPrefixDef","value","nameStart","nameChar","regex","RegExp","test","validateXMLNameProduction","attrNS","toLowerCase","char","comment","validateChar","indexOf","charAt","length","pubId","pubIdChar","systemId","target","data","records","tuple","exists","len","record","i","map","ns","generatedPrefix","elem","prefixMap","elmPrefixList","defNSAttrValue","attributes","attr","namespaceURI","attrPrefix","prefix","prefixDef","localName","nsDef","push","requireWellFormed","Error","replace","ignoreNSDefAttr","result","localNameSet","nsURI","tupleExists","candidatePrefix","includes","generatePrefix","serializeAttrValue","validateXMLAttrName","validatePITarget","validatePIData","trim","markup","docType","validatePublicId","publicId","validateSystemId","name","namespace","childNodes","runSerialization","validateComment","documentElement","serializeDocument","characterSet","validateXMLTagName","qualifiedName","skipEndTag","assign","create","localDefNS","recordElementNSInfo","inheritedNS","serializeAttributes","hasChildNodes","content","contextNamespace","namespacePrefixes","Util","serializeElement","serializeComment","serializeText","serializeDocumentFragment","serializeDocumentType","serializeProcessingInstruction","root","XMLSerializer","serializer","serializeToString","Symbol","toStringTag","installTo"],"mappings":";;;EAAA,SAAS,eAAe,CAAC,QAAQ,EAAE,WAAW,EAAE;EAChD,EAAE,IAAI,EAAE,QAAQ,YAAY,WAAW,CAAC,EAAE;EAC1C,IAAI,MAAM,IAAI,SAAS,CAAC,mCAAmC,CAAC,CAAC;EAC7D,GAAG;EACH,CAAC;;EAED,kBAAc,GAAG,eAAe;;ECNhC,SAAS,iBAAiB,CAAC,MAAM,EAAE,KAAK,EAAE;EAC1C,EAAE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;EACzC,IAAI,IAAI,UAAU,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;EAC9B,IAAI,UAAU,CAAC,UAAU,GAAG,UAAU,CAAC,UAAU,IAAI,KAAK,CAAC;EAC3D,IAAI,UAAU,CAAC,YAAY,GAAG,IAAI,CAAC;EACnC,IAAI,IAAI,OAAO,IAAI,UAAU,EAAE,UAAU,CAAC,QAAQ,GAAG,IAAI,CAAC;EAC1D,IAAI,MAAM,CAAC,cAAc,CAAC,MAAM,EAAE,UAAU,CAAC,GAAG,EAAE,UAAU,CAAC,CAAC;EAC9D,GAAG;EACH,CAAC;;EAED,SAAS,YAAY,CAAC,WAAW,EAAE,UAAU,EAAE,WAAW,EAAE;EAC5D,EAAE,IAAI,UAAU,EAAE,iBAAiB,CAAC,WAAW,CAAC,SAAS,EAAE,UAAU,CAAC,CAAC;EACvE,EAAE,IAAI,WAAW,EAAE,iBAAiB,CAAC,WAAW,EAAE,WAAW,CAAC,CAAC;EAC/D,EAAE,OAAO,WAAW,CAAC;EACrB,CAAC;;EAED,eAAc,GAAG,YAAY;;EChB7B;;;;AAIA,aAAe;EACb;;;;;EAKAA,EAAAA,cANa,0BAMEC,IANF,EAMQ;EACnB,WAAOA,IAAI,IAAIA,IAAI,CAACC,QAAL,KAAkB,CAAjC;EACD,GARY;;EAUb;;;;;EAKAC,EAAAA,aAfa,yBAeCF,IAfD,EAeO;EAClB,WAAOA,IAAI,IAAIA,IAAI,CAACC,QAAL,KAAkB,CAAjC;EACD,GAjBY;;EAmBb;;;;;EAKAE,EAAAA,eAxBa,2BAwBGH,IAxBH,EAwBS;EACpB,WACEA,IAAI,KACHA,IAAI,CAACC,QAAL,KAAkB,CAAlB,IAAuBG,MAAM,CAACC,SAAP,CAAiBC,QAAjB,CAA0BC,IAA1B,CAA+BP,IAA/B,MAAyC,eAD7D,CADN;EAID,GA7BY;;EA+Bb;;;;;EAKAQ,EAAAA,UApCa,sBAoCFR,IApCE,EAoCI;EACf,WAAOA,IAAI,IAAIA,IAAI,CAACC,QAAL,KAAkB,CAAjC;EACD,GAtCY;;EAwCb;;;;;EAKAQ,EAAAA,2BA7Ca,uCA6CeT,IA7Cf,EA6CqB;EAChC,WAAOA,IAAI,IAAIA,IAAI,CAACC,QAAL,KAAkB,CAAjC;EACD,GA/CY;;EAiDb;;;;;EAKAS,EAAAA,aAtDa,yBAsDCV,IAtDD,EAsDO;EAClB,WAAOA,IAAI,IAAIA,IAAI,CAACC,QAAL,KAAkB,CAAjC;EACD,GAxDY;;EA0Db;;;;;EAKAU,EAAAA,aA/Da,yBA+DCX,IA/DD,EA+DO;EAClB,WAAOA,IAAI,IAAIA,IAAI,CAACC,QAAL,KAAkB,EAAjC;EACD,GAjEY;;EAmEb;;;;;EAKAW,EAAAA,iBAxEa,6BAwEKZ,IAxEL,EAwEW;EACtB,WAAOA,IAAI,IAAIA,IAAI,CAACC,QAAL,KAAkB,EAAjC;EACD;EA1EY,CAAf;;ECFA,IAAMY,MAAM,GAAG,sCAAf;EAAA,IACEC,QAAQ,GAAG,+BADb;EAAA,IAEEC,OAAO,GAAG,8BAFZ;;MAIqBC;EACnB;;;;;EAKA,sBAAYC,kBAAZ,EAAgC;EAAA;;EAC9B,SAAKC,WAAL,GAAmB,CAAnB;EACA,SAAKC,YAAL,GAAoB,EAApB;EACA,SAAKF,kBAAL,GAA0BA,kBAAkB,KAAK,KAAvB,GAA+B,KAA/B,GAAuC,IAAjE;EACD;EAED;;;;;;;;;gDAK0BG,OAAO;EAC/B,UAAIC,SAAS,GACT,yEACA,0EADA,GAEA,0EAFA,GAGA,qCAJJ;EAAA,UAKEC,QAAQ,GACND,SAAS,GAAG,8DANhB;EAQA,UAAIE,KAAK,GAAG,IAAIC,MAAJ,aAAgBH,SAAhB,eAA8BC,QAA9B,SAA4C,GAA5C,CAAZ;EACA,aAAO,OAAOF,KAAP,KAAiB,QAAjB,IAA6BG,KAAK,CAACE,IAAN,CAAWL,KAAX,CAApC;EACD;EAED;;;;;;;;yCAKmBA,OAAO;EACxB,aAAO,KAAKM,yBAAL,CAA+BN,KAA/B,KAAyC,CAAC,QAAQK,IAAR,CAAaL,KAAb,CAAjD;EACD;EAED;;;;;;;;;0CAMoBA,OAAOO,QAAQ;EACjC,aACE,KAAKD,yBAAL,CAA+BN,KAA/B,MACCA,KAAK,CAACQ,WAAN,OAAwB,OAAxB,IAAmCD,MAAM,KAAK,IAD/C,CADF;EAID;EAED;;;;;;;;mCAKaP,OAAO;EAClB,UAAIS,KAAI,GACN,sEACA,qCAFF;;EAIA,UAAIN,KAAK,GAAG,IAAIC,MAAJ,aAAgBK,KAAhB,SAAZ;EACA,aAAO,OAAOT,KAAP,KAAiB,QAAjB,IAA6BG,KAAK,CAACE,IAAN,CAAWL,KAAX,CAApC;EACD;EAED;;;;;;;;sCAKgBU,SAAS;EACvB,aACE,KAAKC,YAAL,CAAkBD,OAAlB,KACAA,OAAO,CAACE,OAAR,CAAgB,IAAhB,IAAwB,CADxB,IAEAF,OAAO,CAACG,MAAR,CAAeH,OAAO,CAACI,MAAR,GAAiB,CAAhC,MAAuC,GAHzC;EAKD;EAED;;;;;;;;uCAKiBC,OAAO;EACtB,UAAIC,SAAS,GAAG,qEAAhB;EAEA,UAAIb,KAAK,GAAG,IAAIC,MAAJ,aAAgBY,SAAhB,SAAZ;EACA,aAAO,OAAOD,KAAP,KAAiB,QAAjB,IAA6BZ,KAAK,CAACE,IAAN,CAAWU,KAAX,CAApC;EACD;EAED;;;;;;;;uCAKiBE,UAAU;EACzB,aAAO,KAAKN,YAAL,CAAkBM,QAAlB,CAAP;EACD;EAED;;;;;;;;uCAKiBC,QAAQ;EACvB,aACE,KAAKP,YAAL,CAAkBO,MAAlB,KACAA,MAAM,CAACN,OAAP,CAAe,GAAf,IAAsB,CADtB,IAEAM,MAAM,CAACV,WAAP,OAAyB,KAH3B;EAKD;EAED;;;;;;;;qCAKeW,MAAM;EACnB,aAAO,KAAKR,YAAL,CAAkBQ,IAAlB,KAA2BA,IAAI,CAACP,OAAL,CAAa,IAAb,IAAqB,CAAvD;EACD;EAED;;;;;;;;;kCAMYQ,SAASC,OAAO;EAC1B,UAAIC,MAAM,GAAG,KAAb;EAAA,UACEC,GAAG,GAAGF,KAAK,CAACP,MADd;EAD0B;EAAA;EAAA;;EAAA;EAG1B,6BAAmBM,OAAnB,8HAA4B;EAAA,cAAnBI,MAAmB;;EAC1B,cAAID,GAAG,KAAKC,MAAM,CAACV,MAAnB,EAA2B;EACzBQ,YAAAA,MAAM,GAAG,IAAT;EACA,gBAAIG,CAAC,GAAG,CAAC,CAAT;;EACA,mBAAO,EAAEA,CAAF,GAAMF,GAAb,EAAkB;EAChB,kBAAIC,MAAM,CAACC,CAAD,CAAN,KAAcJ,KAAK,CAACI,CAAD,CAAvB,EAA4B;EAC1BH,gBAAAA,MAAM,GAAG,KAAT;EACA;EACD;EACF;EACF;;EACD,cAAIA,MAAJ,EAAY;EACb;EAfyB;EAAA;EAAA;EAAA;EAAA;EAAA;EAAA;EAAA;EAAA;EAAA;EAAA;EAAA;EAAA;EAAA;;EAgB1B,aAAOA,MAAP;EACD;EAED;;;;;;;;;;qCAOeI,KAAKC,IAAI;EACtB,UAAIC,eAAe,GAAG,OAAO,KAAK9B,WAAL,EAA7B;EACA4B,MAAAA,GAAG,CAACC,EAAD,CAAH,GAAUC,eAAV;EAEA,aAAOA,eAAP;EACD;EAED;;;;;;;;;;;0CAQoBC,MAAMC,WAAWC,eAAe;EAClD;EACA,UAAIC,cAAc,GAAG,IAArB;EAAA,UACEC,UAAU,GAAGJ,IAAI,CAACI,UADpB;EAAA,UAEER,CAAC,GAAG,CAAC,CAFP;EAAA,UAGEF,GAAG,GAAGU,UAAU,CAACnB,MAHnB,CAFkD;;EAQlD,aAAO,EAAEW,CAAF,GAAMF,GAAb,EAAkB;EAChB;EACA,YAAIW,IAAI,GAAGD,UAAU,CAACR,CAAD,CAArB;EAAA,YACElB,MAAM,GAAG2B,IAAI,CAACC,YADhB;EAAA,YAEEC,UAAU,GAAGF,IAAI,CAACG,MAFpB,CAFgB;;EAMhB,YAAI9B,MAAM,KAAKb,QAAf,EAAyB;EACvB;EACA,cAAI0C,UAAU,KAAK,IAAnB,EAAyB;EACvBJ,YAAAA,cAAc,GAAGE,IAAI,CAAClC,KAAtB;EACA;EACD,WALsB;EAQvB;;;EACA,cAAIsC,SAAS,GAAGJ,IAAI,CAACK,SAArB;EAAA,cACEC,KAAK,GAAGN,IAAI,CAAClC,KADf,CATuB;;EAavB,cAAI,OAAO8B,SAAS,CAACU,KAAD,CAAhB,KAA4B,WAA5B,IAA2CV,SAAS,CAACU,KAAD,CAAT,KAAqBF,SAApE,EACE,KAAKvC,YAAL,CAAkB0C,IAAlB,CAAuBH,SAAvB,EADF;EAAA,eAGKR,SAAS,CAACU,KAAD,CAAT,GAAmBF,SAAnB,CAhBkB;;EAmBvBP,UAAAA,aAAa,CAACU,IAAd,CAAmBH,SAAnB;EACD;EACF;;EACD,aAAON,cAAP;EACD;EAED;;;;;;;;;;;yCAQmBhC,OAAO0C,mBAAmB;EAC3C,UAAIA,iBAAiB,IAAI,CAAC,KAAK/B,YAAL,CAAkBX,KAAlB,CAA1B,EACE,MAAM,IAAI2C,KAAJ,CAAU3C,KAAK,GAAG,iCAAlB,CAAN;EAEF,UAAIA,KAAK,KAAK,IAAd,EAAoB,OAAO,EAAP;EAEpB,aAAOA,KAAK,CACT4C,OADI,CACI,GADJ,EACS,QADT,EAEJA,OAFI,CAEI,GAFJ,EAES,OAFT,EAGJA,OAHI,CAGI,GAHJ,EAGS,MAHT,EAIJA,OAJI,CAII,GAJJ,EAIS,MAJT,CAAP;EAKD;EAED;;;;;;;;;;;;;0CAUoBhE,MAAM8C,KAAKmB,iBAAiBH,mBAAmB;EACjE;EACA,UAAII,MAAM,GAAG,EAAb;EAAA,UACEC,YAAY,GAAG,EADjB;EAGA,UAAId,UAAU,GAAGrD,IAAI,CAACqD,UAAtB;EAAA,UACER,CAAC,GAAG,CAAC,CADP;EAAA,UAEEF,GAAG,GAAGU,UAAU,CAACnB,MAFnB,CALiE;;EAUjE,aAAO,EAAEW,CAAF,GAAMF,GAAb,EAAkB;EAChB,YAAIW,IAAI,GAAGD,UAAU,CAACR,CAAD,CAArB;EAAA,YACEuB,KAAK,GAAGd,IAAI,CAACC,YADf;EAAA,YAEEI,SAAS,GAAGL,IAAI,CAACK,SAFnB;EAAA,YAGEF,MAAM,GAAGH,IAAI,CAACG,MAHhB;EAKA,YAAIhB,KAAK,GAAG,CAAC2B,KAAD,EAAQT,SAAR,CAAZ,CANgB;;EAQhB;;EACA,YAAIG,iBAAiB,IAAI,KAAKO,WAAL,CAAiBF,YAAjB,EAA+B1B,KAA/B,CAAzB,EACE,MAAM,IAAIsB,KAAJ,CACJ,6EADI,CAAN,CAVc;;EAehBI,QAAAA,YAAY,CAACN,IAAb,CAAkBpB,KAAlB,EAfgB;;EAkBhB,YAAId,MAAM,GAAGyC,KAAb;EAAA,YACEE,eAAe,GAAG,IADpB,CAlBgB;;EAqBhB;;EACA,YAAI3C,MAAM,KAAK,IAAf,EAAqB;EACnB;EACA,cACEA,MAAM,KAAKb,QAAX,KACE2C,MAAM,KAAK,IAAX,IAAmBQ,eAApB,IACER,MAAM,KAAK,IAAX,IAAmB,KAAKtC,YAAL,CAAkBoD,QAAlB,CAA2BZ,SAA3B,CAFtB,CADF,EAIE;EACA;EACD,WAND,MAMO,IAAIF,MAAM,KAAK,IAAf,EAAqB;EAC1Ba,YAAAA,eAAe,GAAG,IAAlB;EACD,WAFM;EAAA,eAKF,IAAI,OAAOxB,GAAG,CAACnB,MAAD,CAAV,KAAuB,WAA3B,EAAwC;EAC3C2C,cAAAA,eAAe,GAAGxB,GAAG,CAACnB,MAAD,CAArB;EACD,aAFI;EAAA,iBAKA;EACH2C,gBAAAA,eAAe,GAAG,KAAKE,cAAL,CAAoB1B,GAApB,EAAyBnB,MAAzB,CAAlB;EACAuC,gBAAAA,MAAM,qBAAcI,eAAd,gBAAkC,KAAKG,kBAAL,CAAwB9C,MAAxB,CAAlC,OAAN;EACD;EACF,SA5Ce;;;EA+ChBuC,QAAAA,MAAM,IAAI,GAAV,CA/CgB;;EAkDhB,YAAII,eAAe,KAAK,IAAxB,EAA8BJ,MAAM,IAAII,eAAe,GAAG,GAA5B,CAlDd;;EAqDhB;;EACA,YAAIR,iBAAiB,IAAI,CAAC,KAAKY,mBAAL,CAAyBf,SAAzB,EAAoChC,MAApC,CAA1B,EACE,MAAM,IAAIoC,KAAJ,CAAUJ,SAAS,GAAG,oCAAtB,CAAN,CAvDc;;EA0DhBO,QAAAA,MAAM,cAAOP,SAAP,gBAAqB,KAAKc,kBAAL,CAAwBnB,IAAI,CAAClC,KAA7B,CAArB,OAAN;EACD,OArEgE;;;EAwEjE,aAAO8C,MAAP;EACD;EAED;;;;;;;;;;qDAO+BlE,MAAM8D,mBAAmB;EACtD;EACA,UAAIA,iBAAiB,IAAI,CAAC,KAAKa,gBAAL,CAAsB3E,IAAI,CAACsC,MAA3B,CAA1B,EACE,MAAM,IAAIyB,KAAJ,CACJ/D,IAAI,CAACsC,MAAL,GAAc,qDADV,CAAN,CAHoD;;EAQtD,UAAIwB,iBAAiB,IAAI,CAAC,KAAKc,cAAL,CAAoB5E,IAAI,CAACuC,IAAzB,CAA1B,EACE,MAAM,IAAIwB,KAAJ,CACJ/D,IAAI,CAACuC,IAAL,GAAY,2DADR,CAAN;EAIF,UAAID,MAAM,GAAG,KAAKrB,kBAAL,GAA0BjB,IAAI,CAACsC,MAA/B,GAAwCtC,IAAI,CAACsC,MAAL,CAAYuC,IAAZ,EAArD;EAAA,UACEtC,IAAI,GAAG,KAAKtB,kBAAL,GAA0BjB,IAAI,CAACuC,IAA/B,GAAsCvC,IAAI,CAACuC,IAAL,CAAUsC,IAAV,EAD/C,CAbsD;;EAgBtD,UAAIC,MAAM,eAAQxC,MAAR,cAAkBC,IAAlB,OAAV,CAhBsD;;EAmBtD,aAAOuC,MAAP;EACD;EAED;;;;;;;;;;;4CAQsBC,SAASjB,mBAAmB;EAChD;EACA,UAAIA,iBAAiB,IAAI,CAAC,KAAKkB,gBAAL,CAAsBD,OAAO,CAACE,QAA9B,CAA1B,EACE,MAAM,IAAIlB,KAAJ,CACJgB,OAAO,CAACE,QAAR,GAAmB,sDADf,CAAN,CAH8C;;EAQhD,UAAInB,iBAAiB,IAAI,CAAC,KAAKoB,gBAAL,CAAsBH,OAAO,CAAC1C,QAA9B,CAA1B,EACE,MAAM,IAAI0B,KAAJ,CACJgB,OAAO,CAAC1C,QAAR,GAAmB,yDADf,CAAN,CAT8C;;EAchD,UAAIyC,MAAM,GAAG,YAAb;EAAA,UACEG,QAAQ,GAAG,KAAKhE,kBAAL,GAA0B8D,OAAO,CAACE,QAAlC,GAA6CF,OAAO,CAACE,QAAR,CAAiBJ,IAAjB,EAD1D;EAAA,UAEExC,QAAQ,GAAG,KAAKpB,kBAAL,GAA0B8D,OAAO,CAAC1C,QAAlC,GAA6C0C,OAAO,CAAC1C,QAAR,CAAiBwC,IAAjB,EAF1D;EAIA,UAAII,QAAQ,KAAK,EAAb,IAAmB5C,QAAQ,KAAK,EAAhC,IAAsC,UAAUZ,IAAV,CAAesD,OAAO,CAACI,IAAvB,CAA1C,EACEL,MAAM,IAAIC,OAAO,CAACI,IAAR,CAAavD,WAAb,EAAV,CADF,KAEKkD,MAAM,IAAIC,OAAO,CAACI,IAAlB,CApB2C;;EAuBhD,UAAIF,QAAQ,KAAK,EAAjB,EAAqBH,MAAM,wBAAgBG,QAAhB,OAAN,CAvB2B;;EA0BhD,UAAI5C,QAAQ,KAAK,EAAb,IAAmB4C,QAAQ,KAAK,EAApC,EAAwCH,MAAM,aAAN,CA1BQ;;EA6BhD,UAAIzC,QAAQ,KAAK,EAAjB,EAAqByC,MAAM,iBAASzC,QAAT,OAAN,CA7B2B;;EAgChDyC,MAAAA,MAAM,IAAI,GAAV;EAEA,aAAOA,MAAP;EACD;EAED;;;;;;;;;;;;gDAS0B9E,MAAMoF,WAAWlC,WAAWY,mBAAmB;EACvE,UAAIgB,MAAM,GAAG,EAAb;EAAA,UACEO,UAAU,GAAGrF,IAAI,CAACqF,UADpB;EAAA,UAEE1C,GAAG,GAAG0C,UAAU,CAACnD,MAFnB;EAAA,UAGEW,CAAC,GAAG,CAAC,CAHP;;EAKA,aAAO,EAAEA,CAAF,GAAMF,GAAb,EAAkB;EAChBmC,QAAAA,MAAM,IAAI,KAAKQ,gBAAL,CACRD,UAAU,CAACxC,CAAD,CADF,EAERuC,SAFQ,EAGRlC,SAHQ,EAIRY,iBAJQ,CAAV;EAMD;;EACD,aAAOgB,MAAP;EACD;EAED;;;;;;;;;oCAMc9E,MAAM8D,mBAAmB;EACrC,UAAIA,iBAAiB,IAAI,CAAC,KAAK/B,YAAL,CAAkB/B,IAAI,CAACuC,IAAvB,CAA1B,EACE,MAAM,IAAIwB,KAAJ,CAAU/D,IAAI,CAACuC,IAAL,GAAY,+BAAtB,CAAN;EAEF,UAAIA,IAAI,GAAG,KAAKtB,kBAAL,GAA0BjB,IAAI,CAACuC,IAA/B,GAAsCvC,IAAI,CAACuC,IAAL,CAAUsC,IAAV,EAAjD;EACA,aAAOtC,IAAI,CACRyB,OADI,CACI,KADJ,EACW,OADX,EAEJA,OAFI,CAEI,IAFJ,EAEU,MAFV,EAGJA,OAHI,CAGI,IAHJ,EAGU,MAHV,CAAP;EAID;EAED;;;;;;;;;uCAMiBhE,MAAM8D,mBAAmB;EACxC,UAAIA,iBAAiB,IAAI,CAAC,KAAKyB,eAAL,CAAqBvF,IAAI,CAACuC,IAA1B,CAA1B,EACE,MAAM,IAAIwB,KAAJ,CAAU/D,IAAI,CAACuC,IAAL,GAAY,kCAAtB,CAAN;EAEF,aAAO,SAASvC,IAAI,CAACuC,IAAd,GAAqB,KAA5B;EACD;EAED;;;;;;;;;;;;wCASkBvC,MAAMoF,WAAWlC,WAAWY,mBAAmB;EAC/D,UAAIA,iBAAiB,IAAI9D,IAAI,CAACwF,eAAL,KAAyB,IAAlD,EACE,MAAM,IAAIzB,KAAJ,CAAU,uCAAV,CAAN;EAEF,UAAI0B,iBAAiB,8CAAoCzF,IAAI,CAAC0F,YAAzC,SAArB;EAEA,UAAIL,UAAU,GAAGrF,IAAI,CAACqF,UAAtB;EAAA,UACE1C,GAAG,GAAG0C,UAAU,CAACnD,MADnB;EAAA,UAEEW,CAAC,GAAG,CAAC,CAFP;;EAIA,aAAO,EAAEA,CAAF,GAAMF,GAAb,EAAkB;EAChB8C,QAAAA,iBAAiB,IAAI,KAAKH,gBAAL,CACnBD,UAAU,CAACxC,CAAD,CADS,EAEnBuC,SAFmB,EAGnBlC,SAHmB,EAInBY,iBAJmB,CAArB;EAMD;;EACD,aAAO2B,iBAAP;EACD;EAED;;;;;;;;;;;;uCASiBzF,MAAMoF,WAAWlC,WAAWY,mBAAmB;EAC9D,UAAIH,SAAS,GAAG3D,IAAI,CAAC2D,SAArB,CAD8D;EAG9D;;EACA;;EACA,UAAIG,iBAAiB,IAAI,CAAC,KAAK6B,kBAAL,CAAwBhC,SAAxB,CAA1B,EACE,MAAM,IAAII,KAAJ,CAAUJ,SAAS,GAAG,wCAAtB,CAAN,CAN4D;EAS9D;EACA;EACA;;EACA,UAAImB,MAAM,GAAG,GAAb;EAAA,UACEc,aAAa,GAAG,EADlB;EAAA,UAEEC,UAAU,GAAG,KAFf;EAAA,UAGE5B,eAAe,GAAG,KAHpB;EAAA,UAIEnB,GAAG,GAAG1C,MAAM,CAAC0F,MAAP,CAAc1F,MAAM,CAAC2F,MAAP,CAAc,IAAd,CAAd,EAAmC7C,SAAnC,CAJR;EAAA,UAKEC,aAAa,GAAG,EALlB,CAZ8D;;EAoB9D,WAAKhC,YAAL,GAAoB,EAApB,CApB8D;EAuB9D;;EACA,UAAI6E,UAAU,GAAG,KAAKC,mBAAL,CACbjG,IADa,EAEb8C,GAFa,EAGbK,aAHa,EAIb,KAAKhC,YAJQ,CAAjB;EAAA;EAOE;EACA+E,MAAAA,WAAW,GAAGd,SARhB;EAAA,UASErC,EAAE,GAAG/C,IAAI,CAACuD,YATZ,CAxB8D;;EAoC9D,UAAI2C,WAAW,KAAKnD,EAApB,EAAwB;EACtB;;EACA;EACA,YAAIiD,UAAU,KAAK,IAAnB,EAAyB/B,eAAe,GAAG,IAAlB,CAHH;;EAMtB;;EACA,YAAIlB,EAAE,KAAKlC,MAAX,EAAmB+E,aAAa,GAAG,SAASjC,SAAzB,CAAnB;EAAA,aAEKiC,aAAa,GAAGjC,SAAhB,CATiB;;EAYtBmB,QAAAA,MAAM,IAAIc,aAAV;EACD,OAbD;EAAA,WAgBK;EACH;EACA,cAAInC,MAAM,GAAGzD,IAAI,CAACyD,MAAlB;EAAA,cACEa,eAAe,GAAG,OAAOxB,GAAG,CAACC,EAAD,CAAV,KAAmB,WAAnB,GAAiCD,GAAG,CAACC,EAAD,CAApC,GAA2C,IAD/D,CAFG;;EAMH;;EACA,cAAIuB,eAAe,KAAK,IAAxB,EAA8B;EAC5B;EACAsB,YAAAA,aAAa,GAAGtB,eAAe,GAAG,GAAlB,GAAwBX,SAAxC,CAF4B;;EAK5B;;EACA,gBAAIqC,UAAU,KAAK,IAAnB,EAAyBE,WAAW,GAAGnD,EAAd,CANG;;EAS5B+B,YAAAA,MAAM,IAAIc,aAAV;EACD,WAVD;EAAA,eAaK,IAAInC,MAAM,KAAK,IAAX,IAAmBuC,UAAU,KAAK,IAAtC,EAA4C;EAC/C;EACA,kBAAI7C,aAAa,CAACoB,QAAd,CAAuBd,MAAvB,CAAJ,EAAoC;EAClC;EACAA,gBAAAA,MAAM,GAAG,KAAKe,cAAL,CAAoB1B,GAApB,EAAyBC,EAAzB,CAAT;EACD,eAHD;EAAA,mBAKK;EACHD,kBAAAA,GAAG,CAACC,EAAD,CAAH,GAAUU,MAAV;EACD,iBAT8C;;;EAY/CmC,cAAAA,aAAa,GAAGnC,MAAM,GAAG,GAAT,GAAeE,SAA/B,CAZ+C;;EAc/CmB,cAAAA,MAAM,IAAIc,aAAV,CAd+C;;EAiB/Cd,cAAAA,MAAM,qBAAcrB,MAAd,gBAAyB,KAAKgB,kBAAL,CAAwB1B,EAAxB,EAA4Be,iBAA5B,CAAzB,OAAN;EACD,aAlBI;EAAA,iBAqBA,IAAIkC,UAAU,KAAK,IAAf,IAAuBA,UAAU,KAAKjD,EAA1C,EAA8C;EACjD;EACAkB,gBAAAA,eAAe,GAAG,IAAlB;EACA2B,gBAAAA,aAAa,GAAGjC,SAAhB;EACAuC,gBAAAA,WAAW,GAAGnD,EAAd,CAJiD;;EAOjD+B,gBAAAA,MAAM,IAAIc,aAAV,CAPiD;;EAUjDd,gBAAAA,MAAM,uBAAe,KAAKL,kBAAL,CAAwB1B,EAAxB,EAA4Be,iBAA5B,CAAf,OAAN;EACD,eAXI;EAAA,mBAcA;EACH8B,kBAAAA,aAAa,GAAGjC,SAAhB;EACAuC,kBAAAA,WAAW,GAAGnD,EAAd;EACA+B,kBAAAA,MAAM,IAAIc,aAAV;EACD;EACF,SAhH6D;;;EAmH9Dd,MAAAA,MAAM,IAAI,KAAKqB,mBAAL,CAAyBnG,IAAzB,EAA+B8C,GAA/B,EAAoCmB,eAApC,EAAqDH,iBAArD,CAAV,CAnH8D;;EAsH9D,UACEf,EAAE,KAAKhC,OAAP,IACA,CAACf,IAAI,CAACoG,aAAL,EADD,IAEA,mHAAmH3E,IAAnH,CACEkC,SADF,CAHF,EAME;EACAmB,QAAAA,MAAM,IAAI,IAAV;EACAe,QAAAA,UAAU,GAAG,IAAb;EACD,OA/H6D;;;EAkI9D,UAAI9C,EAAE,KAAKhC,OAAP,IAAkB,CAACf,IAAI,CAACoG,aAAL,EAAvB,EAA6C;EAC3CtB,QAAAA,MAAM,IAAI,GAAV;EACAe,QAAAA,UAAU,GAAG,IAAb;EACD,OArI6D;;;EAwI9Df,MAAAA,MAAM,IAAI,GAAV,CAxI8D;;EA2I9D,UAAIe,UAAJ,EAAgB,OAAOf,MAAP,CA3I8C;;EA8I9D,UAAI/B,EAAE,KAAKhC,OAAP,IAAkB4C,SAAS,CAAC/B,WAAV,OAA4B,UAAlD,EAA8D;EAC5DkD,QAAAA,MAAM,IAAI,KAAKQ,gBAAL,CAAsBtF,IAAI,CAACqG,OAA3B,EAAoCH,WAApC,EAAiDpD,GAAjD,EAAsDgB,iBAAtD,CAAV;EACD,OAFD;EAAA,WAKK;EACH,cAAInB,GAAG,GAAG3C,IAAI,CAACqF,UAAL,CAAgBnD,MAA1B;EAAA,cACEW,CAAC,GAAG,CAAC,CADP;;EAEA,iBAAO,EAAEA,CAAF,GAAMF,GAAb,EAAkB;EAChBmC,YAAAA,MAAM,IAAI,KAAKQ,gBAAL,CACRtF,IAAI,CAACqF,UAAL,CAAgBxC,CAAhB,CADQ,EAERqD,WAFQ,EAGRpD,GAHQ,EAIRgB,iBAJQ,CAAV;EAMD;EACF,SA9J6D;;;EAiK9DgB,MAAAA,MAAM,IAAI,OAAOc,aAAP,GAAuB,GAAjC;EAEA,aAAOd,MAAP;EACD;EAED;;;;;;;;;;;;uCASiB9E,MAAMsG,kBAAkBC,mBAAmBzC,mBAAmB;EAC7E,UAAI0C,IAAI,CAACtG,aAAL,CAAmBF,IAAnB,CAAJ,EACE,OAAO,KAAKyG,gBAAL,CACLzG,IADK,EAELsG,gBAFK,EAGLC,iBAHK,EAILzC,iBAJK,CAAP;EAOF,UAAI0C,IAAI,CAACzG,cAAL,CAAoBC,IAApB,CAAJ,EACE,OAAO,KAAKyF,iBAAL,CACLzF,IADK,EAELsG,gBAFK,EAGLC,iBAHK,EAILzC,iBAJK,CAAP;EAOF,UAAI0C,IAAI,CAAC9F,aAAL,CAAmBV,IAAnB,CAAJ,EAA8B,OAAO,KAAK0G,gBAAL,CAAsB1G,IAAtB,EAA4B8D,iBAA5B,CAAP;EAE9B,UAAI0C,IAAI,CAAChG,UAAL,CAAgBR,IAAhB,CAAJ,EAA2B,OAAO,KAAK2G,aAAL,CAAmB3G,IAAnB,EAAyB8D,iBAAzB,CAAP;EAE3B,UAAI0C,IAAI,CAAC5F,iBAAL,CAAuBZ,IAAvB,CAAJ,EACE,OAAO,KAAK4G,yBAAL,CACL5G,IADK,EAELsG,gBAFK,EAGLC,iBAHK,EAILzC,iBAJK,CAAP;EAOF,UAAI0C,IAAI,CAAC7F,aAAL,CAAmBX,IAAnB,CAAJ,EACE,OAAO,KAAK6G,qBAAL,CAA2B7G,IAA3B,EAAiC8D,iBAAjC,CAAP;EAEF,aAAO,KAAKgD,8BAAL,CAAoC9G,IAApC,EAA0C8D,iBAA1C,CAAP;EACD;EAED;;;;;;;;;;;;wCASkBiD,MAAMjD,mBAAmB;EACzC;EACA,UAAIwC,gBAAgB,GAAG,IAAvB;EAAA,UACEC,iBAAiB,GAAGnG,MAAM,CAAC2F,MAAP,CAAc,IAAd,CADtB,CAFyC;EAKzC;EACA;;EACAQ,MAAAA,iBAAiB,CAACzF,QAAD,CAAjB,GAA8B,OAA9B,CAPyC;;EAUzC,WAAKI,WAAL,GAAmB,CAAnB;EAEA4C,MAAAA,iBAAiB,GAAGA,iBAAiB,GAAG,IAAH,GAAU,KAA/C;EAEA,aAAO,KAAKwB,gBAAL,CACLyB,IADK,EAELT,gBAFK,EAGLC,iBAHK,EAILzC,iBAJK,CAAP;EAMD;;;;;;MCttBGkD;EACJ;;;;EAIA,yBAAY/F,kBAAZ,EAAgC;EAAA;;EAC9B,SAAKgG,UAAL,GAAkB,IAAIjG,UAAJ,CAAeC,kBAAf,CAAlB;EACD;EAED;;;;;;;;EAOA;;;;;;;;wCAQkB8F,MAAMjD,mBAAmB;EACzC,aAAO,KAAKmD,UAAL,CAAgBC,iBAAhB,CAAkCH,IAAlC,EAAwCjD,iBAAxC,CAAP;EACD;;WAdIqD,MAAM,CAACC;0BAAe;EACzB,aAAO,eAAP;EACD;;;;;EAeH;;;;;EAGAJ,aAAa,CAACK,SAAd,GAA0B,UAAA/E,MAAM,EAAI;EAClCA,EAAAA,MAAM,CAAC0E,aAAP,GAAuBA,aAAvB;EACD,CAFD;;;;;;;;"}